<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 甜树果子二号</title>
    <link>http://example.org/post/</link>
    <description>Recent content in Posts on 甜树果子二号</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Jan 2023 00:30:49 +0800</lastBuildDate><atom:link href="http://example.org/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>http://example.org/post/my-first-post/</link>
      <pubDate>Wed, 18 Jan 2023 00:30:49 +0800</pubDate>
      
      <guid>http://example.org/post/my-first-post/</guid>
      <description>This is a test blog.
This is a test blog.
This is a test blog.
博客主题</description>
    </item>
    
    <item>
      <title>Android的消息机制</title>
      <link>http://example.org/post/android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
      <description>概述 Handler是Android中消息机制的上层接口，所以开发过程中只需要和Handler交互即可。通过Handler就可以将一个任务切换到Handler所在线程中执行。其中的一个应用场景就是在子线程中执行耗时操作例如读取文件访问网络等以后可以通过handler将更新UI（UI非线程安全，android当中不允许在子线程中更新；而耗时操作如果在主线程进行会造成ANR）的操作切换回主线程中执行。
Android中的消息机制主要是指Handler的运行机制。Handler创建时会采用当前线程的Looper来构建内部消息循环系统，然后可以通过Handler的一系列post方法（内部也是通过send方法完成的）将一个Runnable对象投递到Handler内部的Looper中去处理，或者通过Handler的一系列send方法发送一个消息到Looper中去处理，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列待Looper处理。
分析 ThreadLocal的作用 使用场景 定义：ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后只能在指定的线程中获取到存储的数据，其他线程无法获取。
使用场景：（1）当某些数据是以线程为作用域并且不同线程具有不同的数据副本时就可以采用ThreadLocal。（2）复杂逻辑下的对象传递，比如监听器的传递，有的时候一个线程中的任务过于复杂，可能表现为函数调用栈比较深以及代码入口的多样性，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以采用ThreadLocal。
典型场景1：每个线程需要一个独享的对象（比如一些工具类，由于本身不是线程安全，如果多个线程共享同一个静态工具类的话有一定风险，就使用ThreadLocal给每个线程制造一个独享的对象，线程之间持有不同的实例就不会互相影响了，典型需要使用的类有SimpleDateFormat和Random）。让某个需要用到的对象在线程间隔离。 典型场景2：每个线程内需要保存全局变量（比如一些常用业务内容），以便让不同方法直接使用，避免繁琐的传参。这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。使用ThreadLocal的话，无需使用synchronized关键字，可以在不影响性能的情况下，无需层层传递参数，就可以达到保存当前线程可以使用的信息的目的。在线程的生命周期内，通过静态ThreadLocal实例的get()方法取得自己set过的对象。在任何方法中都可以轻松获取到该对象。 好处： 达到线程安全 不需加锁，提高执行效率 更高效利用内存、节省开销：相比于每个任务都新建一个实例，使用ThreadLocal可以节省内存和开销.（比如100个任务提交给拥有10个线程的线程池，只要保证10个线程各自拥有一个处理任务的工具类实例就行，而不需要每个任务创建一个） 免去传参的繁琐：使代码耦合度更低、更优雅。 原理 工作过程：不同的线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个ThreadLocalMap，然后再从ThreadLocalMap中以当前ThreadLocal作为key去查找对应的value值，不同线程中的ThreadLocalMap是不同的，所以可以通过ThreadLocal在不同线程中维护一套数据的副本而互不干扰。
内部实现：
ThreadLocal是一个泛型类public class ThreadLocal
initialValue()
该方法会返回当前线程对应的“初始值”，是一个延迟加载的方法，只有调用get的时候，才会触发。除非线程先前调用set方法(在这种情况下，不会为线程调用本initialValue方法)。 通常每个线程最多调用一次此方法，但如果已经调用了remove后，再调用get方法，则可以再次调用此方法。 如果不重写此方法，默认返回null。一般使用匿名内部类来重写initialValue方法，以便在后续使用中可以初始化副本对象。 public void set(T value) { Thread t = Thread.currentThread(); //取出当前线程的ThreadLocalMap //ThreadLocalMap不是Map，但是可以理解为Map ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value);//key是ThreadLocal当前变量，value是我们需要的值 else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } //Thread内定义了成员threadLocals //设置到ThreadLocal中的数据也就是写入了threadLocals这个ThreadLocalMap ThreadLocal.ThreadLocalMap threadLocals = null; //threadLocals本身就保存了当前线程所有“局部变量”，也就是一个ThreadLocal变量的集合。 public T get() { Thread t = Thread.</description>
    </item>
    
    <item>
      <title>OkHttp梳理</title>
      <link>http://example.org/post/okhttp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/okhttp/</guid>
      <description>OkHttp梳理 OkHttp的使用 添加依赖
基本代码
class Util{ public static void sendRequest(String url, Callback callback) { RequestBody requestBody = new FormBody.Builder() .add(&amp;#34;key&amp;#34;,&amp;#34;content&amp;#34;) .build(); Request request = new Request.Builder() .url(url) .post(requestBody) .build(); OkHttpClient client = new OkHttpClient(); client.newCall(request).enqueue(callback);//异步请求的方式 //同步请求方式则是调用execute方法，并且有Response类型的返回值。 } } OkHttp请求的整体流程 OkHttp请求过程中最少只需要接触OkHttpClient、Request、Call、 Response，但是内部会进行大量的逻辑处理。所有网络请求的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。
分发器：内部维护队列与线程池，完成请求调配。 拦截器：五大默认拦截器完成整个请求过程。 整个网络请求过程大致过程：
通过建造者模式构建OKHttpClient与 Request。 OKHttpClient通过newCall发起一个新的请求。 通过分发器维护请求队列与线程池，完成请求调配。 通过五大默认拦截器完成请求重试，缓存处理，建立连接等一系列操作。 得到网络请求结果。 OKHttp分发器工作 分发器的主要作用是维护请求队列与线程池。（比如我们有100个异步请求，肯定不能把它们同时请求，而是应该把它们排队分个类，分为正在请求中的列表和正在等待的列表，请求完成后，可从等待中的列表中取出等待的请求，从而完成所有的请求。）
同步请求 因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。后续按照加入队列的顺序同步请求即可。
//Dispatcher.kt @Synchronized internal fun executed(call: RealCall) { runningSyncCalls.add(call) } 异步请求 Dispatcher将AsyncCall加到了readyAsyncCalls的队尾，并检测是否存在跟当前请求域名相同的请求，如果存在则复用，然后调用promoteAndExecute方法处理请求。
//Dispatcher.kt internal fun enqueue(call: AsyncCall) { synchronized(this) { readyAsyncCalls.</description>
    </item>
    
    <item>
      <title>网络层</title>
      <link>http://example.org/post/%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
      <description>网络层提供的两种服务
由于计算机有很强的差错处理能力，比电话机智能许多，所以互联网的设计思路是：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，不提供服务质量的承诺，所传送的分组可能出错、丢失、重复、失序，也不保证分组交付的时限。如果主机中的进程之间的通信需要是可靠的，那么就由主机中的运输层负责（包括差错处理、流量控制等）。
网际协议IP
由于网际协议IP是用来使互连起来的许多计算机网络能够进行通信的	，因此TCP/IP体系中的网络层也常常被称为网际层或者IP层。
虚拟互联网络
将网络互相连接起来要使用一些中间设备，从网络层看就是路由器，路由器就是一台专用计算机，用来在互联网中进行路由选择。许多计算机网络通过一些路由器进行互连，由于参加互连的计算机网络都使用相同的网际协议IP，因此可以把互连以后的计算机网络看成一个虚拟互联网络，也就是逻辑互联网络，互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来像是一个统一的网络，主机之间进行通信看不见互连各网络的例如编址方案、路由选择协议等具体异构细节。
分类的IP地址
IP地址就是给互联网上的每一台主机或者路由器的每一个接口分配一个在全世界范围内是唯一的32位标识符。
IP地址的编址经过三个阶段：分类的IP地址、子网的划分、构成超网。
分类的IP地址：IP地址::= {&amp;lt;网络号&amp;gt;,&amp;lt;主机号&amp;gt;}
A类：0网络号（8位）
B类：10网络号（16位）
C类：110网络号（24位）
D类：1110多播地址
E类：1111保留
IP地址与硬件地址
物理地址是数据链路层和物理层使用的地址，物理地址就是硬件地址，已经固化在网卡的ROM（只读存储器）上，因为局域网的MAC帧中的源地址和目的地址都是硬件地址，所以又称为MAC地址，路由器收到MAC帧以后会丢弃掉原来的首部和尾部，转发时重新添加新的首部和尾部。而IP地址是网络层和以上各层使用的地址，是一种逻辑地址，IP数据报首部的源地址和目的地址始终不变。
地址解析协议ARP
网络层使用IP地址，但是在实际网络的链路上传送数据最终还是必须使用该网络的硬件地址。地址解析协议可以根据IP地址得出硬件地址，在主机ARP高速缓存中存放了本局域网上的各主机和路由器的IP地址到硬件地址的映射表，并且这个映射表会经常动态更新。所以ARP是解决同一个局域网上的主机或者路由器的IP地址和硬件地址的映射问题，如果两个主机不在同一个局域网上是无法解析出另一个主机的硬件地址的。
某台主机A向另外一台主机B发送IP数据报。
如果AB在同一个局域网中：首先在ARP高速缓存中查看主机B的IP地址，如果有就可以直接查出硬件地址；如果没有查询到IP地址（可能B刚接入网或者A刚通电，ARP高速缓存还是空），ARP进程在本局域网上广播发送一个包含自己IP地址和硬件地址的ARP请求分组，得到B的ARP响应，A与B都更新ARP高速缓存，添加对方的IP地址到硬件地址的映射。
如果AB不在同一个局域网中：在ARP高速缓存中不会查询到，通过广播也不可能会有响应，那就把IP数据报通过和A连接在同一局域网的路由器来转发，这个转发的过程要先把路由器的IP地址解析为硬件地址，然后路由器收到IP数据报以后从转发表中找到下一跳路由器（路由器连接了不同的网络），由这个路由器继续转发。
网络链路上传送的帧最终是按照硬件地址找到目的主机的，但是由于世界上存在各式各样复杂的网络，如果是这些异构网络能够仅适用硬件地址进行通信就必须进行非常复杂的硬件地址转换工作，所以通过IP编址是简化了这个问题，连接到互联网的主机只要拥有一个唯一的IP地址，他们之间的通信就像连接在同一个网络上一样简便，ARP的复杂过程都是由计算机软件自动进行，对上层屏蔽。
IP数据报的格式
首部+数据部分。其中首部固定长度20字节，加上可选字段不超过60字节，4字节整数倍。
版本（4）：通信双方使用的IP协议版本需要一致。 首部长度（4）：单位是4字节。 区分服务（8）：使用区分服务时才会使用到。 总长度（16）：首部+数据之和的长度，单位是字节；当一个IP数据报封装成数据链路帧时，此数据报的长度不能超过下面数据链路层所规定的MTU最大传送单元，如果超过就把过长的数据进行分片处理。 标识（16）：具有相同标识字段的值使分片后各数据报片最后能正确重装成原来的数据报。 标志（3）：最低位MF=1表示后面还有分片；中位DF=1表示不能分片。 片偏移（13）：指出在原分组中相对于用户数据字段的的起点，以8字节为偏移单位，也就是说每个分片的长度都是8字节的整数倍。 生存时间（8）：表明数据报在网络中的寿命，防止无法交付的数据报无限制地在互联网中兜圈子，消耗网络资源。这个TTL字段的单位为跳数，指明在互联网中最多可以经过多少个路由器。 协议（8）：指出此数据报携带的数据是使用何种协议，能够将数据部分上交给哪个协议处理。 首部检验和（16）：只检验数据报首部。 源地址（32） 目的地址（32） 可变部分+填充：可用于支持排错、测量及安全等措施，内容比较丰富，是为了增加IP数据报的功能。（IPv6已经将IP数据报首部长度做成固定了） IP层转发分组的流程
互联网上转发分组时，是从一个路由器转发到下一个路由器。路由表中最重要的信息：目的网络地址，下一跳地址，于是就可以根据目的地址确定下一跳路由器，到达最后一个路由器时就可以试图向目的主机进行直接交付。
当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址以后，不是把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的IP地址通过ARP地址解析协议转换成硬件地址，并将这个硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。（整个过程包含直接交付或者间接交付，还有选择特定主机路由或者默认主机路由，以及转发分组出错的情况）
划分子网和构造超网
划分子网
两级IP地址的设计上出现了IP地址空间的利用率有时很低、每个物理网络分配一个网络号使路由表变得太大而使网络性能变化、两级IP地址不够灵活等的问题。而划分子网的方式能够较好地解决这些问题，它会从网络的主机号借用若干位作为子网号，这样就使两级IP地址变为三级IP地址，但只是把IP地址主机号这部分再进行再划分，不改变IP地址原来的网络号。同时，将物理网络划分为若干个子网时一个单位内部的事情，本单位以外是看不见这个网络有多少子网构成的。
划分子网以后，路由器收到外来数据报就可以根据目的地址转发到响应的子网。为了使路由器能够很方便地从数据报中的目的IP地址中提取出所要找的子网的网络地址，路由器就要使用三级IP地址的子网掩码和数据报目的IP地址逐位相与，得出所要找的子网的网络地址。即是不划分子网时，也可以通过子网掩码更方便地查找路由，现在所有网络都必须使用子网掩码，同时在路由器的路由表中也必须由子网掩码这一项，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器，如果一个网络不划分子网，那么这个网络的子网掩码就用默认子网掩码，其中1的位置和IP地址中网络号字段对应，逐位与正好能得出是哪一类IP地址。
使用子网时分组的转发
这个时候路由表中应该要包含目的网络地址、目的网络子网掩码、下一跳地址。
转发算法：首先提取目的IP地址；判断是否直接交付，也就是使用各个子网的子网掩码与目的IP地址逐位相遇，判断子网号是否相同，如果遇到相同子网号，就可以进行直接交付了；如果与所有的子网号都不符合，再去查看特定主机路由；如果没有特定主机路由，再去检测路由表中有无转发途径，目的IP地址和路由表中每一项的子网掩码都逐位相与，如果某一项的子网掩码与目的IP地址得出的结果正好就是对应的网络，就可以走下一跳地址了；如果检测完了整个路由表都没有可选路径，才进入默认路由，发给另外一个路由器，接着会循环上一各步骤。当然这个循环也是有限制的，如果超过了生存时间还没有到达目的地址，就只能被丢弃了，报告转发分组出错。
无分类编址CIDR（构造超网）
在子网划分的基础上，将定长子网掩码变为变长子网掩码，是更加灵活的无分类编址方法。
无分类域间路由选择CIDR：（1）消除了传统分类地址以及划分子网的概念，又从三级地址回归到了两集地址，由网络前缀+主机号构成，也就是把子网号合并到网络前缀当中了。CIDR记法：&amp;lt;IP地址&amp;gt;/网络前缀位数。（2）融合了子网地址和子网掩码，方便子网划分。CIDR把网络前缀都相同的连续的IP地址组成一个CIDR地址块。
将多个子网聚合成一个较大的子网，就是构成超网，或者路由聚合，方法就是将网络前缀缩短。使用CIDR时，查找路由表可能得到几个匹配结果，应该选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体。
网际控制报文协议ICMP
ICMP是网络层与运输层之间的协议，起了桥梁的作用，是为了更有效地转发IP数据报和提高交付成功的机会。ICMP允许主机或者路由器进行差错和异常情况的报告与网络探询。
ICMP报文格式
类型（8） 代码（8） 检验和（16） 紧接着的四个字节取决于ICMP报文的类型（32） ICMP的数据部分（长度取决于类型） ICMP报文的种类
ICMP差错报告报文：3终点不可达（无法交付）、11时间超过（TTL=0）、12参数问题（首部字段有问题）、5改变路由（让主机知道下次选择哪个更好的路由）
所有ICMP差错报告报文的数据字段都有同样的格式，把收到的需要进行差错报告的**IP数据报的首部和数据字段的前8个字节（得到运输层的源端口号与目的端口号，以及序列号）**提取出来，作为ICMP的数据字段。再加上响应的ICMP差错报告的报文的前8个字节，就构成了ICMP差错报告报文。
然后整个ICMP报文作为IP数据报的数据字段发送给源点。
ICMP询问报文：8/0回送请求或回答、13/14时间戳请求或回答
主机或者路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或者路由器发送ICMP回送回答报文。可测试目的站是否可达以及了解相关状态，例如ping。
请求某个主机或者路由器回答当前的日期和时间。可用来进行时钟同步和测量时间。
ICMP的应用举例</description>
    </item>
    
    <item>
      <title>运输层</title>
      <link>http://example.org/post/%E8%BF%90%E8%BE%93%E5%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/%E8%BF%90%E8%BE%93%E5%B1%82/</guid>
      <description>运输层协议
进程之间的通信
运输层的复用和分用
应用层所有应用进程都可以通过运输层再传送到IP层；
运输层从IP层收到发送给各个应用进程的数据后，必须分别交付指明的各应用进程。
面向连接的TCP和无连接的UDP
TCP报文段和UDP用户数据报
运输层的端口
用一种统一的方法标记本计算机应用层的各个进程和运输层交互的层间接口。
服务端使用的端口号（熟知端口号&amp;amp;登记端口号）和客户端使用的端口号（短暂端口号）
TCP 传输控制协议TCP TCP是面向连接的传输层协议（应用程序使用TCP协议之前需要建立TCP连接。传送数据完毕后，必须释放已经建立的TCP连接）
点对点连接
可靠交付（无差错、不丢失、不重复、按序到达）
全双工通信（允许通信双方的应用进程在任何时候都能发送数据）
发送缓存&amp;amp;接收缓存 面向字节流（TCP把应用程序交下来的数据仅仅看做一串无结构的字节流。1. 接收方的应用程序必须有能力识别接收到的字节流，把它还原成有意义的应用层数据。TCP并不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应该包含多少个字节。2. 如果应用进程传到TCP缓存的数据块太长，TCP就可以划分短一些再传送；反之也可以等待积累足够多字节后再构成报文段发送。）（而UDP发送的报文长度是应用进程给出的。）
TCP报文段先要传送到IP层，加上IP首部以后，再传送到数据链路层，再加上首部和尾部以后，才离开主机发送到物理链路。TCP并不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据接收方给出的窗口值和当前网络的拥塞程度再来决定一个报文段应该包含多少字节。
TCP的连接 每一条TCP连接两个端点（这个端点不是IP地址，不是应用进程，也不是运输层的协议端口），叫套接字socket或者插口。 套接字socket=（IP地址：端口号） 可靠传输的工作原理 (理想传输条件：传输信道不产生差错&amp;amp;不管发送方以多快的速度发送数据，接收方总是来的及处理收到的数据)而网络层提供的是不可靠的传输，传输层就要使用一些可靠传输协议：当出现差错时可以让发送方重传出现差错的数据；同时在接收方来不及处理收到的数据时，即时告知发送方适当降低发送数据的速度。
停止等待协议：自动重传请求ARQ（Automatic Repeat reQueset）（学习概念思想就好，运输层并不使用这种协议）
无差错情况 出现差错、确认丢失、确认迟到 超时重传、超时计时器、编号（适用这种确认和重传机制，就可以在不可靠的传输网络上实现可靠的通信）
简单，但是信道利用率太低，可以采用流水线传输。
连续ARQ协议（累积确认，接收方对按序到达的最后一个分组发送确认，回退N）
发送方维持发送窗口：位于发送窗口内的分组都可以连续发送出去，而无需等待对方确认；根据收到的确认，向前滑动发送窗口，以便发送新的分组。（信道利用率就比停止等待方式高了。） 接收方累积确认：不必对收到的分组逐个发送确认，而是在收到几十个分组后，对按序到达的最后一个分组发送确认。这样即使确认丢失也不必重传；但是不能向发送方反应出接收方已经正确收到的所有分组信息，可能引起发送方回退N的问题（退回来重传已经发送过的N个分组）。 滑动窗口协议（TCP传输控制协议的精髓）
TCP报文段的首部格式 TCP固定首部20字节，选项部分最长40字节。
源端口&amp;amp;目的端口（各2字节） 序号（4字节）：本报文段所发送数据的第一个字节的序号。TCP连接传送的每一个字节都按顺序编号。 确认号（4字节）：期望收到对方下一个报文段的第一个数据字节的序号。也就是如果确认号是N，表明N-1之前的所有数据都已经正确收到。 数据偏移（4位）：单位是32位字（4字节）；实际上支持的是TCP报文段的首部长度，侧面表达了TCP首部的最大长度是60字节。 保留（6位） 6位控制位：用来说明本报文段的性质 紧急URG 确认ACK：ACK=1时确认号字段才有效；TCP规定，连接建立之后所有传送的报文段都必须ACK=1。 推送PSH 复位RST 同步SYN：连接建立时用来同步序号，SYN=1时表示这是一个连接请求或者连接接收报文。SYN=1&amp;amp;ACK=0（连接请求），SYN=1&amp;amp;ACK=1（连接接受）。 终止FIN：FIN=1，表明此报文段发送方数据已经发送完毕，要求释放运输连接。 窗口（2字节）：以字节为单位，指发送本报文段一方的接收窗口，因为接收方的缓存空间是有限制的，所以要明确指出现在允许发送方发送的数据量，窗口值动态变化，作为发送方设置发送窗口的依据。 检验和（2字节）：TCP报文段前面加上12字节的伪首部计算检验和，检测范围包括首部和数据两部分。 紧急指针（2字节）：在URG=1时有意义，指出本报文段中紧急数据的字节数，紧急数据结束以后就是普通数据。接收方处理紧急数据时会进入紧急状态，当所有紧急数据处理完后，TCP告诉应用进程恢复到正常操作。即使窗口值为零也可以发送紧急数据。 选项（长度可变 &amp;lt;= 40字节，需要对齐填充保证TCP报文段首部是4字节的整数倍）： 最大报文长度 选择确认（SACK） 窗口扩大 时间戳：10字节，主要是时间戳字段（4字节）和时间戳回送回答字段（4字节）。 用来计算往返时间RTT。 用于处理TCP序号超过2^32的情况，防止序号绕回。（使接收方在高速网络状态下，能够将新的报文段和迟到很久的报文段区分开。） …… TCP可靠传输的实现 以字节为单位的滑动窗口
已经发送但未收到确认的数据均需保存副本，以便超时重传时使用。
发送窗口不能超过接收窗口数值，发送窗口同时也会受到网络拥塞程度的制约。
接收窗口只能对按序收到的数据中的最高序号给出确认（累积确认，减少传输开销；选择确认，减少不必要的重传）；对不按序到达的数据临时存放在接收窗口，等待字节流中所缺少的字节收到后才按序交付给应用进程。
为了保证可靠传输，发送方只能认为接收方可能没有收到数据，会在超时计时器的控制下重传数据，直到收到确认。</description>
    </item>
    
  </channel>
</rss>
